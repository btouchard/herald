# CLAUDE.md ‚Äî R√®gles du projet Herald

> Ce fichier est la source de v√©rit√© pour Claude Code. Lis-le enti√®rement avant chaque action.

---

## üîí R√àGLES ABSOLUES (NON N√âGOCIABLES)

- **JAMAIS de `git push`**. Aucune exception. Commit local uniquement.
- **JAMAIS de mention d'IA, de Claude, de LLM, de "generated by" dans les commits, commentaires ou code.**
- **JAMAIS de `--dangerously-skip-permissions`** dans les commandes Claude Code lanc√©es par Herald.
- **JAMAIS de prompt injection** : Herald ne modifie, n'enrichit et n'injecte RIEN dans les prompts utilisateur transmis √† Claude Code. Le prompt part tel quel.
- Les messages de commit suivent le format Conventional Commits : `feat:`, `fix:`, `refactor:`, `test:`, `chore:`, `docs:`.
- Messages de commit en anglais, concis, descriptifs. Exemple : `feat(executor): add stream-json output parsing`.
- Avant de commit, toujours lancer `make lint` et `make test`. Ne commit que du code qui passe.
- **Zero CGO**. Tout le code doit compiler avec `CGO_ENABLED=0`. C'est non n√©gociable pour la cross-compilation et le d√©ploiement en binaire unique.

---

## üì¶ LE PROJET

Herald est un serveur MCP (Model Context Protocol) self-hosted en Go qui connecte nativement Claude Chat (claude.ai / app mobile) √† Claude Code (CLI terminal) via le protocole officiel Custom Connectors d'Anthropic.

**Probl√®me r√©solu** : Claude Chat et Claude Code sont deux syst√®mes totalement isol√©s. Herald est le pont qui permet de rester dans Claude Chat tout en ex√©cutant des t√¢ches sur son poste de travail local via Claude Code.

**Ce que Herald est** : un serveur MCP Streamable HTTP exposant des outils (start_task, check_task, get_result...) que Claude Chat appelle nativement via Custom Connectors.

**Ce que Herald n'est PAS** : un wrapper CLI, une WebUI, un bot Telegram, un proxy API Anthropic, un outil qui outrepasse les instructions de Claude Code.

---

## üèóÔ∏è ARCHITECTURE

### Principes fondamentaux

- **Binaire unique** : tout est embarqu√© dans un seul ex√©cutable Go (~15-20MB). Pas de Docker requis pour tourner.
- **Async-first** : chaque t√¢che Claude Code est un goroutine. Le pattern principal est start/check/result (polling c√¥t√© MCP). Les t√¢ches de type `linked` (cr√©√©es via `herald_push`) repr√©sentent des sessions Claude Code pouss√©es depuis le terminal pour continuation √† distance.
- **Stateless MCP, stateful backend** : le serveur MCP traite chaque requ√™te ind√©pendamment. L'√©tat vit dans SQLite + m√©moire.
- **Fail-safe** : si Herald crash, les processus Claude Code en cours continuent. Les r√©sultats sont persist√©s sur disque.
- **KISS** : pas de sur-ing√©nierie. Si une abstraction n'a qu'une seule impl√©mentation probable, ne pas cr√©er d'interface pr√©matur√©ment. Herald est un outil, pas un framework.

### Flux principal

```
Claude Chat (mobile/web)
  ‚Üí HTTPS (MCP Streamable HTTP + OAuth 2.1 Bearer Token)
  ‚Üí Traefik (reverse proxy, TLS termination)
  ‚Üí Herald Server (Go binary, port 8420)
    ‚Üí MCP Handler (/mcp)
    ‚Üí Task Manager (goroutines)
    ‚Üí Claude Code Executor (os/exec ‚Üí claude -p --output-format stream-json)
    ‚Üí SQLite (persistence)
    ‚Üí MCP Notifications (server push via SSE)

Claude Code (terminal, via herald_push)
  ‚Üí Herald Server
    ‚Üí Task Manager (creates linked task, type=linked, status=linked)
    ‚Üí SQLite (persistence)
  ‚Üí Claude Chat can later list_tasks + start_task to resume
```

### Structure du projet

```
herald/
‚îú‚îÄ‚îÄ cmd/
‚îÇ   ‚îî‚îÄ‚îÄ herald/
‚îÇ       ‚îî‚îÄ‚îÄ main.go                 # Entry point : config ‚Üí wiring ‚Üí start
‚îú‚îÄ‚îÄ internal/
‚îÇ   ‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config.go               # Struct de configuration
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ loader.go               # Chargement YAML + env vars + defaults
‚îÇ   ‚îú‚îÄ‚îÄ mcp/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ server.go               # Setup serveur MCP (mcp-go)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tools.go                # Enregistrement des outils MCP
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ handlers/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ start_task.go       # Tool: start_task
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ check_task.go       # Tool: check_task
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ get_result.go       # Tool: get_result
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ list_tasks.go       # Tool: list_tasks
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cancel_task.go      # Tool: cancel_task
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ get_diff.go         # Tool: get_diff
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ list_projects.go    # Tool: list_projects
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ read_file.go        # Tool: read_file
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ herald_push.go      # Tool: herald_push (bidirectional bridge)
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ get_logs.go         # Tool: get_logs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ middleware/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ auth.go             # OAuth token validation middleware
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ ratelimit.go        # Rate limiting middleware
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ security.go         # Security headers middleware
‚îÇ   ‚îú‚îÄ‚îÄ executor/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ executor.go             # Interface Executor
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ claude.go               # Claude Code executor (os/exec)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ stream.go               # Parsing stream-json output
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ prompt.go               # Prompt file management (work_dir)
‚îÇ   ‚îú‚îÄ‚îÄ task/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ manager.go              # Task lifecycle management
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ task.go                 # Task struct et √©tats
‚îÇ   ‚îú‚îÄ‚îÄ store/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ store.go                # Interface Store
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sqlite.go               # Impl√©mentation SQLite (modernc.org/sqlite)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ migrations.go           # Schema migrations
‚îÇ   ‚îú‚îÄ‚îÄ notify/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ notifier.go             # Interface Notifier + NotificationHub
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ mcp.go                  # MCP server notifications (push via SSE)
‚îÇ   ‚îú‚îÄ‚îÄ auth/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ oauth.go                # OAuth 2.1 server (authorization code + PKCE)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ token.go                # JWT token generation/validation
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ secret.go               # Secret auto-generation and persistence
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ store.go                # Token storage interface
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ sqlitestore.go          # Token storage SQLite implementation
‚îÇ   ‚îú‚îÄ‚îÄ project/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ project.go              # Struct Project
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ manager.go              # Chargement et validation projets
‚îÇ   ‚îî‚îÄ‚îÄ git/
‚îÇ       ‚îî‚îÄ‚îÄ git.go                  # Git operations (diff, branch info)
‚îú‚îÄ‚îÄ configs/
‚îÇ   ‚îî‚îÄ‚îÄ herald.example.yaml         # Configuration exemple
‚îú‚îÄ‚îÄ Dockerfile                      # Multi-stage build (Go 1.26 ‚Üí scratch)
‚îú‚îÄ‚îÄ docker-compose.yml              # Minimal Herald deployment
‚îú‚îÄ‚îÄ Makefile
‚îú‚îÄ‚îÄ go.mod
‚îú‚îÄ‚îÄ go.sum
‚îú‚îÄ‚îÄ LICENSE                         # AGPL-3.0
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ CHANGELOG.md
‚îî‚îÄ‚îÄ CLAUDE.md                       # Ce fichier
```

### R√®gles de d√©pendances

```
cmd/herald (wiring)
  ‚îî‚îÄ‚îÄ internal/mcp        ‚Üí internal/task, internal/project, internal/auth
  ‚îî‚îÄ‚îÄ internal/task        ‚Üí internal/executor, internal/store, internal/notify
  ‚îî‚îÄ‚îÄ internal/executor    ‚Üí (os/exec, rien d'interne)
  ‚îî‚îÄ‚îÄ internal/store       ‚Üí (modernc.org/sqlite, rien d'interne)
  ‚îî‚îÄ‚îÄ internal/notify      ‚Üí (net/http, rien d'interne)
```

- Chaque package `internal/` est autonome et ne d√©pend pas des autres sauf via interfaces.
- Le wiring (injection de d√©pendances) se fait dans `cmd/herald/main.go` uniquement.
- `internal/executor` ne conna√Æt RIEN du MCP ou de l'auth. Il ex√©cute des commandes et rapporte des r√©sultats.
- `internal/store` ne conna√Æt RIEN du MCP. Il persiste et requ√™te des donn√©es.

---

## üêπ GO 1.26 ‚Äî CONVENTIONS ET IDIOMES

### D√©pendances externes

| Package | Version | Usage |
|---|---|---|
| `github.com/mark3labs/mcp-go` | v0.27+ | Serveur MCP Streamable HTTP |
| `github.com/go-chi/chi/v5` | v5.1+ | Router HTTP (REST API) |
| `modernc.org/sqlite` | v1.34+ | SQLite pure Go, zero CGO |
| `github.com/google/uuid` | v1.6+ | G√©n√©ration UUID |
| `gopkg.in/yaml.v3` | v3.0+ | Parsing configuration YAML |
| `github.com/stretchr/testify` | v1.9+ | Assertions tests (assert/require) |

**C'est tout.** Six d√©pendances. Pas de zerolog, pas de zap, pas de GORM, pas de x/oauth2, pas de x/crypto.

Le logging, l'error handling avanc√©, et le multi-handler sont en **stdlib Go 1.26**.

### Idiomes Go 1.26 obligatoires

**`new(expr)` pour l'initialisation de pointeurs :**

```go
// ‚úÖ Go 1.26
task := &Task{
    Timeout:  new(30),
    DryRun:   new(false),
    Priority: new("normal"),
}

// ‚ùå Ancien style ‚Äî interdit dans ce projet
timeout := 30
task := &Task{Timeout: &timeout}
```

**`errors.AsType[E]` pour le matching d'erreurs :**

```go
// ‚úÖ Go 1.26 ‚Äî type-safe, 3x plus rapide, z√©ro reflection
if execErr, ok := errors.AsType[*exec.ExitError](err); ok {
    slog.Error("claude code failed", "exit_code", execErr.ExitCode())
}

if sqlErr, ok := errors.AsType[*sqlite.Error](err); ok {
    slog.Error("database error", "code", sqlErr.Code())
}

// ‚ùå Ancien style ‚Äî interdit dans ce projet
var execErr *exec.ExitError
if errors.As(err, &execErr) { ... }
```

**`log/slog` pour tout le logging (JAMAIS de zerolog, zap, logrus) :**

```go
// ‚úÖ slog stdlib
slog.Info("task started",
    "task_id", task.ID,
    "project", task.Project,
    "priority", task.Priority)

slog.Error("execution failed",
    "task_id", task.ID,
    "error", err,
    "duration", time.Since(start))

// Multi-destination avec slog.NewMultiHandler (Go 1.26)
handler := slog.NewMultiHandler(stdoutHandler, fileHandler)
logger := slog.New(handler)

// ‚ùå Interdit
log.Info().Str("task_id", id).Msg("started")  // zerolog
zap.L().Info("started", zap.String("task_id", id))  // zap
```

**`io.ReadAll` sans h√©sitation :**

```go
// Go 1.26 : ~2x plus rapide, ~50% moins d'allocations
// Utiliser sans culpabilit√© pour lire les outputs Claude Code
output, err := io.ReadAll(stdoutPipe)
```

**`bytes.Buffer.Peek(n)` pour l'inspection non-destructive :**

```go
// Inspecter le type d'√©v√©nement stream-json sans consommer le buffer
prefix := buf.Peek(40)
if bytes.Contains(prefix, []byte(`"type":"result"`)) {
    // Traitement prioritaire
}
```

### Error handling

- Toujours v√©rifier les erreurs. Jamais de `_ = someFunc()` pour une erreur.
- Wrapper avec contexte : `fmt.Errorf("failed to start claude code: %w", err)`.
- `%w` une seule fois par couche pour permettre `errors.Is` / `errors.AsType`.
- Le logging se fait au niveau handler/main, pas dans les couches basses. Ne jamais logger ET retourner une erreur.
- Jamais de `panic` en production sauf dans `main()` pour un setup fatal.
- Utiliser `errors.AsType[E]` (Go 1.26) syst√©matiquement au lieu de `errors.As`.

### Interfaces

- D√©finir les interfaces c√¥t√© consommateur, pas c√¥t√© impl√©mentation.
- Petites interfaces : 1 √† 3 m√©thodes max.
- Les interfaces cl√©s du projet :
  - `store.Store` ‚Äî persistance (impl√©ment√©e par SQLite)
  - `executor.Executor` ‚Äî ex√©cution de t√¢ches (impl√©ment√©e par Claude Code)
  - `notify.Notifier` ‚Äî envoi de notifications (impl√©ment√©e par MCPNotifier)

### Concurrence

- Toujours `context.Context` comme premier param√®tre des fonctions longues ou annulables.
- Chaque t√¢che Claude Code tourne dans son propre goroutine, g√©r√© par le task manager.
- Prot√©ger les goroutines avec `recover()` pour √©viter les crashes silencieux.
- Channels pour la communication (events, notifications), mutex pour l'√©tat partag√© (task map, queue).
- **Attention aux goroutine leaks** : builder avec `GOEXPERIMENT=goroutineleakprofile` en CI.

### Packages interdits

- `github.com/rs/zerolog` ‚Äî utiliser `log/slog` (stdlib Go 1.26)
- `go.uber.org/zap` ‚Äî utiliser `log/slog`
- `github.com/sirupsen/logrus` ‚Äî utiliser `log/slog`
- `gorm.io/gorm` ‚Äî utiliser `modernc.org/sqlite` avec du SQL brut
- N'importe quel ORM
- Tout package n√©cessitant CGO
- `github.com/gorilla/mux` ‚Äî archiv√©, utiliser `chi`

---

## üîê S√âCURIT√â ‚Äî R√àGLES CRITIQUES

Herald expose Claude Code sur le r√©seau. La s√©curit√© n'est pas optionnelle.

### R√®gles de s√©curit√© inviolables

1. **Herald √©coute sur `127.0.0.1` uniquement.** Jamais sur `0.0.0.0`. Traefik g√®re l'exposition r√©seau et le TLS.
2. **OAuth 2.1 avec PKCE** obligatoire pour le endpoint MCP. Aucune requ√™te MCP sans Bearer token valide.
3. **Pas de `--dangerously-skip-permissions`** par d√©faut. Les `allowed_tools` sont pass√©s explicitement √† Claude Code par projet.
4. **Path traversal prevention** sur `read_file` : le path r√©solu doit toujours rester sous le r√©pertoire du projet. Utiliser `filepath.Abs` + `strings.HasPrefix`.
5. **Rate limiting** : 200 requ√™tes/minute par token. Configurable mais activ√© par d√©faut.
6. **Timeouts obligatoires** : chaque t√¢che a un timeout (d√©faut 30 min, max configurable). Pas de t√¢che infinie.
7. **Prompts jamais modifi√©s** : Herald transmet le prompt tel quel. Pas d'injection, pas d'enrichissement, pas de system prompt ajout√©.
8. **Tokens courte dur√©e** : access token 1h, refresh token 30j, rotation √† chaque refresh.
9. **Audit trail** : chaque action (task create, cancel, file read) est logg√©e avec timestamp et identit√©.

### Path traversal ‚Äî impl√©mentation obligatoire

```go
func safePath(projectRoot, requestedPath string) (string, error) {
    absRoot, _ := filepath.Abs(projectRoot)
    absPath, _ := filepath.Abs(filepath.Join(projectRoot, requestedPath))
    if !strings.HasPrefix(absPath, absRoot+string(filepath.Separator)) {
        return "", fmt.Errorf("path traversal detected: %s", requestedPath)
    }
    return absPath, nil
}
```

Cette fonction DOIT √™tre appel√©e dans `read_file` et dans toute op√©ration touchant au filesystem d'un projet.

---

## üß™ STRAT√âGIE DE TESTS

### Philosophie

- **Tester le comportement, pas l'impl√©mentation.** Un test valide un cas d'usage, pas la structure interne.
- **JAMAIS de tests triviaux** : pas de test pour un getter, un constructeur sans logique, ou un mapping √©vident. Chaque test justifie son existence par un risque r√©el de r√©gression.
- **Les tests sont de la documentation vivante** : les noms d√©crivent le comportement attendu.

### Pyramide de tests

```
         ‚ï±  E2E (Herald + Claude Code r√©el)   ‚ï≤    ‚Üê Optionnel, CI avec API key
        ‚ï±   Int√©gration (SQLite, filesystem)    ‚ï≤   ‚Üê Handlers MCP + store + executor mock
       ‚ï±    Unitaire (logique pure)               ‚ï≤  ‚Üê Stream parser, queue, config, git ops
```

### Tests Go

**Unitaires** (`*_test.go` colocalis√©s) :

- Table-driven tests syst√©matiquement pour les cas multiples.
- Pattern : `TestNomFonction_QuandCondition_AlorsResultat`.
- `t.Helper()` pour les fonctions utilitaires de test.
- `t.Parallel()` quand les tests sont ind√©pendants.

```go
func TestParseStreamEvent_WhenResultSuccess_SetsCompletedStatus(t *testing.T) {
    t.Parallel()
    // Arrange
    input := `{"type":"result","subtype":"success","session_id":"ses_abc","cost_usd":0.34}`
    task := &Task{ID: "herald-test01", Status: StatusRunning}

    // Act
    event, err := parseStreamLine([]byte(input))

    // Assert
    require.NoError(t, err)
    assert.Equal(t, "result", event.Type)
    assert.Equal(t, "success", event.Subtype)
    assert.InDelta(t, 0.34, event.CostUSD, 0.001)
}

func TestQueue_WhenUrgentPriority_ExecutesBeforeNormal(t *testing.T) {
    t.Parallel()
    q := NewQueue(3)

    normal := &Task{ID: "t1", Priority: PriorityNormal, Status: StatusQueued}
    urgent := &Task{ID: "t2", Priority: PriorityUrgent, Status: StatusQueued}

    q.Enqueue(normal)
    q.Enqueue(urgent)

    next := q.Next()
    assert.Equal(t, "t2", next.ID, "urgent task should execute first")
}
```

**Int√©gration** (`tests/integration/`, build tag `//go:build integration`) :

- SQLite en m√©moire pour les tests store.
- Mock executor (pas de vrai Claude Code) pour les tests task lifecycle.
- `httptest.Server` pour les tests handlers MCP et REST API.

**Goroutine leak tests** (Go 1.26) :

```bash
# Builder et tester avec d√©tection de fuites de goroutines
GOEXPERIMENT=goroutineleakprofile go test ./tests/integration/... -v -run TestNoGoroutineLeak
```

### Commandes

```bash
# Tous les tests + race detector
make test
# ‚Üí go test ./... -race -count=1

# Couverture
make test-cover
# ‚Üí go test ./... -race -count=1 -coverprofile=coverage.out

# go vet
make vet
# ‚Üí go vet ./...

# Linting
make lint
# ‚Üí golangci-lint run
```

### Couverture minimale

- Stream parser, queue, config loader : > 80%.
- MCP handlers : tester les cas d'erreur et les edge cases.
- Store SQLite : tester CRUD + migrations.
- Auth OAuth : tester le flow complet (authorize ‚Üí code ‚Üí token ‚Üí refresh ‚Üí revoke).
- Executor : tester avec mock (pas de vrai Claude Code en CI).

---

## üê≥ DOCKER

### Philosophie

Herald est con√ßu pour tourner en binaire direct (pas dans Docker) car il a besoin d'acc√©der au filesystem local et au binaire `claude`. Docker est fourni comme **option**, pas comme recommandation.

### Dockerfile (production)

```dockerfile
FROM golang:1.26-alpine AS builder
RUN apk add --no-cache git
WORKDIR /build
COPY go.mod go.sum ./
RUN go mod download
COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -ldflags="-s -w" -o herald ./cmd/herald

FROM scratch
COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/
COPY --from=builder /build/herald /herald
EXPOSE 8420
VOLUME ["/data", "/config"]
HEALTHCHECK --interval=30s --timeout=3s CMD ["/herald", "health"]
ENTRYPOINT ["/herald"]
CMD ["serve", "--config", "/config/herald.yaml"]
```

### Docker Compose

Le docker-compose est fourni pour un d√©ploiement minimal de Herald. Il requiert des volumes mont√©s pour acc√©der √† la configuration et aux donn√©es persist√©es.

---

## üìù CONVENTIONS DE NOMMAGE

### Go

- Fichiers : `snake_case.go`
- Packages : un seul mot lowercase (`executor`, `notify`, `auth`, `store`, `task`)
- Interfaces : nom descriptif sans pr√©fixe `I` (`Store`, pas `IStore`)
- Mocks : pr√©fixe `mock` (`mockStore`, `mockExecutor`)
- Fichiers de test : `*_test.go` colocalis√©s avec le code test√©
- Build tags pour les tests d'int√©gration : `//go:build integration`

### IDs de t√¢ches

Format : `herald-{8 hex chars}` ‚Äî Exemple : `herald-a1b2c3d4`

```go
func GenerateTaskID() string {
    b := make([]byte, 4)
    rand.Read(b)
    return fmt.Sprintf("herald-%x", b)
}
```

### Configuration

- Fichier principal : `~/.config/herald/herald.yaml`
- Variables d'environnement : pr√©fixe `HERALD_` (ex: `HERALD_CLIENT_SECRET`)
- Secrets : toujours via env vars, jamais en dur dans le YAML

### Git

- Branches de travail Herald : `herald/{task-id-short}-{description}`
- Branches dev : `feat/description`, `fix/description`, `refactor/description`
- Commits : `type(scope): description` en anglais

---

## üîë PROTOCOLE MCP ‚Äî R√àGLES SP√âCIFIQUES

### Outils MCP expos√©s

Herald expose exactement 10 outils MCP via le endpoint `/mcp` :

| Outil | Description | Critique |
|---|---|---|
| `start_task` | Lance une t√¢che Claude Code, retourne task_id | C≈ìur du produit |
| `check_task` | Statut et progression d'une t√¢che | C≈ìur du produit |
| `get_result` | R√©sultat complet (summary/full/json) | C≈ìur du produit |
| `list_tasks` | Liste des t√¢ches avec filtres | |
| `cancel_task` | Annule une t√¢che (SIGTERM ‚Üí SIGKILL) | |
| `get_diff` | Diff Git des changements d'une t√¢che | |
| `list_projects` | Projets configur√©s + √©tat Git | |
| `read_file` | Lire un fichier d'un projet (path-safe) | ‚ö†Ô∏è S√©curit√© |
| `herald_push` | Push session Claude Code vers Herald (pont bidirectionnel) | |
| `get_logs` | Logs et historique | |

### R√©ponses MCP

Les r√©ponses doivent √™tre format√©es pour √™tre lisibles dans Claude Chat. Utiliser des emojis, des puces, et une structure claire :

```
‚úÖ Task completed

‚Ä¢ ID: herald-a1b2c3d4
‚Ä¢ Project: my-api
‚Ä¢ Duration: 3m 45s
‚Ä¢ Cost: $0.34
‚Ä¢ Files: 4 modified (+127/-23 lines)

Summary: Added rate limiting middleware...

üí° Use get_diff to see changes, or get_result for full output.
```

### Gestion des prompts longs

Claude Code a des limites quand le prompt d√©passe ~7000 chars en argument CLI. Strat√©gie obligatoire :

1. √âcrire le prompt dans `{work_dir}/tasks/{task_id}/prompt.md`
2. Piper via stdin : `cat prompt.md | claude -p --output-format stream-json`
3. Ne JAMAIS passer un long prompt en argument de ligne de commande

---

## ‚úÖ CHECKLIST AVANT COMMIT

1. [ ] `make lint` passe sans erreur
2. [ ] `make test` passe (unit + race detector)
3. [ ] Le code compile avec `CGO_ENABLED=0`
4. [ ] Pas de secrets, tokens, ou mots de passe en dur
5. [ ] Pas de `--dangerously-skip-permissions` dans le code
6. [ ] Path traversal prevention sur tout acc√®s filesystem
7. [ ] Le message de commit est en Conventional Commits, en anglais, sans mention d'IA
8. [ ] Pas de `git push`

---

## üîÑ WORKFLOW DE D√âVELOPPEMENT

1. **Comprendre** : lire l'issue/la demande compl√®tement avant de coder.
2. **Concevoir** : identifier les composants touch√©s (executor? store? MCP handler?).
3. **Impl√©menter** : √©crire le code avec les tests unitaires correspondants.
4. **Tester** : `make test` passe, `make lint` passe.
5. **V√©rifier la s√©curit√©** : path traversal? injection? timeout? rate limit?
6. **Commit** : message Conventional Commits, diff propre, pas de fichiers temporaires.

### Commandes utiles

```bash
make build              # Compiler le binaire
make test               # Tous les tests + race detector
make test-cover         # Tests avec rapport de couverture
make vet                # go vet
make lint               # golangci-lint
make run                # Compiler et lancer le serveur
make dev                # Hot reload avec air
```

---

## ‚ö†Ô∏è CE QUE CLAUDE CODE NE DOIT JAMAIS FAIRE

- Push du code (`git push`, `git push --force`, etc.)
- Mentionner l'IA/Claude/GPT/LLM dans le code, les commits, les commentaires ou la documentation
- Utiliser un ORM, zerolog, zap, logrus, ou tout package remplac√© par la stdlib Go 1.26
- Cr√©er des packages fourre-tout (`utils`, `helpers`, `common`, `shared`, `misc`)
- √âcrire des tests triviaux qui n'apportent aucune valeur
- Ignorer les erreurs avec `_`
- Utiliser `panic` pour du flow control
- Utiliser `errors.As` au lieu de `errors.AsType` (Go 1.26)
- Utiliser l'ancien style `ptr := val; &ptr` au lieu de `new(val)` (Go 1.26)
- Laisser des `TODO` ou `FIXME` sans issue associ√©e
- Committer du code qui ne compile pas ou dont les tests √©chouent
- Modifier le schema SQLite sans migration dans `internal/store/migrations.go`
- Exposer Herald sur `0.0.0.0` (localhost uniquement, Traefik devant)
- Ajouter `--dangerously-skip-permissions` o√π que ce soit
- Modifier les prompts utilisateur (pas d'injection, pas d'enrichissement)
- Utiliser des d√©pendances n√©cessitant CGO
